package de.unima.ki.narminer.utils;

import au.com.bytecode.opencsv.CSVWriter;
import org.apache.log4j.Logger;

import java.io.*;
import java.util.*;

/**
 * Implements a transaction database to be used in association rule mining
 */
public class TransactionDatabase {
    public static final Logger log = Logger.getLogger(TransactionDatabase.class);

    private LinkedList<Transaction> transactions;
    private HashMap<Integer, ArrayList<Transaction>> itemLookupMap;
    private TreeSet<Integer> allItems;
    private HashMap<Itemset, Double> supportMap;

    private TransactionDatabase inverted;

    /**
     * Constructs the transaction database from the data provided by the given InputStream
     *
     * @param stream   input stream to read data from
     * @param allItems uses the given set as universe of items
     * @throws java.io.IOException if an error occurs while reading the given input stream
     */
    public TransactionDatabase(InputStream stream, TreeSet<Integer> allItems) throws IOException {
        this.itemLookupMap = new HashMap<Integer, ArrayList<Transaction>>();
        this.allItems = allItems;
        this.transactions = new LinkedList<Transaction>();
        this.supportMap = new HashMap<Itemset, Double>();


        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));

        String line;
        while ((line = reader.readLine()) != null) {
            Transaction t = new Transaction();
            String[] elements = line.split("\\s");
            for (String e : elements) {
                int val = Integer.valueOf(e);

                if (!itemLookupMap.containsKey(val)) {
                    itemLookupMap.put(val, new ArrayList<Transaction>());
                }
                itemLookupMap.get(val).add(t);

                t.add(val);
            }

            transactions.add(t);
        }

        log.info("Done loading transaction database (" + this.getStatistics() + ")");
    }

    /**
     * Constructs the transaction database from the data provided by the given InputStream. the required universe of
     * items set is generated by using the highest id read from the input string and setting the universe to everything
     * in the range from 0 to the highest id value.
     *
     * @param stream input stream to read data from
     * @throws java.io.IOException if an error occurs while reading the given InputStream
     */
    public TransactionDatabase(InputStream stream) throws IOException {
        this.itemLookupMap = new HashMap<Integer, ArrayList<Transaction>>();
        this.transactions = new LinkedList<Transaction>();
        this.supportMap = new HashMap<Itemset, Double>();

        BufferedReader reader = new BufferedReader(new InputStreamReader(stream));

        int highestItem = 0;
        int lowestItem = Integer.MAX_VALUE;

        String line;
        while ((line = reader.readLine()) != null) {
            Transaction t = new Transaction();
            String[] elements = line.split("\\s+");
            for (String e : elements) {
                int val = Integer.valueOf(e);

                if (val > highestItem) {
                    highestItem = val;
                }
                
                if (val < lowestItem) {
                    lowestItem = val;
                }

                if (!itemLookupMap.containsKey(val)) {
                    itemLookupMap.put(val, new ArrayList<Transaction>());
                }
                itemLookupMap.get(val).add(t);

                t.add(val);
            }

            transactions.add(t);
        }

        allItems = new TreeSet<Integer>();

        for (int i = 0; i <= highestItem; i++) {
            allItems.add(i);
        }

        log.info("Done loading transaction database (" + this.getStatistics() + ")");
    }

    /**
     * Internal constructor used for creating the inverted variant of the original database
     *
     * @param orig transaction database to invert
     */
    private TransactionDatabase(TransactionDatabase orig) {
        log.info("Creating inverted transaction database");
        this.allItems = new TreeSet<Integer>(orig.allItems);
        this.transactions = new LinkedList<Transaction>();
        this.itemLookupMap = new HashMap<Integer, ArrayList<Transaction>>();
        this.supportMap = new HashMap<Itemset, Double>();

        for (Transaction t : orig.transactions) {
            Transaction invT = new Transaction(this.allItems);
            invT.minus(t);
            this.transactions.add(invT);

            for (Integer item : invT) {
                if (!itemLookupMap.containsKey(item)) {
                    itemLookupMap.put(item, new ArrayList<Transaction>());
                }
                itemLookupMap.get(item).add(t);
            }
        }
        log.info("Done creating inverted transaction database (" + this.getStatistics() + ")");
    }

    /**
     * Writes out a transaction table making items not contained
     *
     * used for naive application of AR mining
     */
    public void writeNaiveDatabase(OutputStream out) throws IOException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(out));
        ArrayList<Integer> itemList = new ArrayList<Integer>(allItems);

        // determine constant value to add for non-existing items
        int summand = 1;
        while (summand <= itemList.size()) {
            summand *= 10;
            if (summand <= 1) {
                throw new RuntimeException("Too many items");
            }
        }

        Collections.sort(itemList);
        for (Transaction t : transactions) {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < itemList.size(); i++) {
                Integer curItem = itemList.get(i);
                if (i != 0) {
                    sb.append("\t");
                }
                if (t.contains(curItem)) {
                    sb.append(curItem);
                }
                else {
                    sb.append(curItem + summand);
                }
            }

            writer.write(sb.toString());
            writer.newLine();
        }
    }

    /**
     * Returns a string containing the most important statistics regarding this transaction database
     *
     * @return string containing the most important statistics
     */
    public String getStatistics() {
        return "Transactions: " + transactions.size() + ", Number of items: " + allItems.size();
    }

    /**
     * Returns an unmodifiable set containing all items of this transaction database (universe of items)
     *
     * @return universe of items
     */
    public Set<Integer> getAllItems() {
        return Collections.unmodifiableSet(allItems);
    }

    /**
     * Returns the list of all transaction contained in this table
     *
     * @return unmodifiable list of all transactions contained in this table
     */
    public List<Transaction> getAllTransactions() {
        return Collections.unmodifiableList(transactions);
    }

    /**
     * Returns the list of transactions containing the given item
     *
     * @param item id of item
     * @return list of transactions containing the given item
     */
    public List<Transaction> getTransactionsContainingItem(int item) {
        return Collections.unmodifiableList(itemLookupMap.get(item));
    }

    /**
     * Returns the inverted version of this transaction database. No modifications are made in this version
     *
     * @return inverted version of this transaction database
     */
    public TransactionDatabase invert() {
        return new TransactionDatabase(this);
    }

    /**
     * Returns all transactions which contain all item of the given set
     *
     * @param set set of items which have to be contained in the transactions
     * @return transactions containing all items contained in set
     */
    public HashSet<Transaction> getTransactionsContaining(Itemset set) {
        HashSet<Transaction> transactionsContainingAllItems = null;

        for (Integer item : set) {
            if (transactionsContainingAllItems == null) {
                transactionsContainingAllItems =
                    itemLookupMap.get(item) == null ? null : new HashSet<Transaction>(itemLookupMap.get(item));
                continue;
            }

            transactionsContainingAllItems.retainAll(itemLookupMap.get(item));
        }

        if (transactionsContainingAllItems == null) {
            transactionsContainingAllItems = new HashSet<Transaction>();
        }

        return transactionsContainingAllItems;
    }

    /**
     * Returns all transactions which do not contain the given transactions
     *
     * @param set itemset which should not be contained in the transactions
     * @return transactions not containing the given itemset
     */
    public HashSet<Transaction> getTransactionsNotContaining(Itemset set) {
        HashSet<Transaction> transactionsContainingAll = getTransactionsContaining(set);
        HashSet<Transaction> allTransactions = new HashSet<Transaction>(transactions);

        allTransactions.removeAll(transactionsContainingAll);

        return allTransactions;
    }

    /**
     * Returns the support for the given set of transactions
     *
     * @param transactions set of transactions to determine support value for
     * @return support value for the given set of transactions
     */
    public double getSupport(Set<Transaction> transactions) {
        return (double) transactions.size() / this.transactions.size();
    }

    /**
     * Returns the support for the given itemset considering negation
     *
     * @param itemset itemset to return support for
     * @param negated boolean flag if itemset is negated
     * @return support for itemset
     */
    public double getSupport(Itemset itemset, boolean negated) {
        int numTransactions = getTransactionsContaining(itemset).size();

        if (negated) {
            numTransactions = transactions.size() - numTransactions;
        }

        return numTransactions / transactions.size();
    }

    /**
     * Returns the support value for the union of the given two itemsets considering negation
     *
     * @param itemset1 first itemset
     * @param negated1 flag if first itemset is negated
     * @param itemset2 second itemset
     * @param negated2 flag if second itemset is negated
     * @return support value for given itemsets
     */
    public double getSupport(Itemset itemset1, boolean negated1, Itemset itemset2, boolean negated2) {
        HashSet<Transaction> transactions1;

        if (negated1) {
            transactions1 = getTransactionsNotContaining(itemset1);
        }
        else {
            transactions1 = getTransactionsContaining(itemset1);
        }

        HashSet<Transaction> transactions2;

        if (negated2) {
            transactions2 = getTransactionsNotContaining(itemset2);
        }
        else {
            transactions2 = getTransactionsContaining(itemset2);
        }

        transactions1.retainAll(transactions2);

        return (double) transactions1.size() / transactions.size();
    }

    /**
     * Returns the interest value for the given itemsets considering negations
     *
     * @param itemset1 first itemset
     * @param negated1 flag if first itemset is negated
     * @param itemset2 second itemset
     * @param negated2 flag if second itemset is negated
     * @return interest value for given itemsets
     */
    public double getInterest(Itemset itemset1, boolean negated1, Itemset itemset2, boolean negated2) {
        HashSet<Transaction> transactions1;

        if (negated1) {
            transactions1 = getTransactionsNotContaining(itemset1);
        }
        else {
            transactions1 = getTransactionsContaining(itemset1);
        }

        double support1 = (double) transactions1.size() / transactions.size();

        HashSet<Transaction> transactions2;

        if (negated2) {
            transactions2 = getTransactionsNotContaining(itemset2);
        }
        else {
            transactions2 = getTransactionsContaining(itemset2);
        }

        double support2 = (double) transactions2.size() / transactions.size();

        transactions1.retainAll(transactions2);

        return Math.abs((transactions1.size() / transactions.size()) - (support1 * support2));
    }

    /**
     * Returns the support value for the given association rule
     *
     * @param rule association rule to determine support value for
     * @return support value for the given association rule
     */
    public double getSupport(AssociationRule rule) {
        return getSupport(rule.getAntecedent(), rule.isAntecedentNegated(), rule.getConsequent(),
                          rule.isConsequentNegated());
    }

    /**
     * Returns the confidence for the antecent and consequent
     *
     * @param rule association rule to return confidence for
     * @return confidence value
     */
    public double getConfidence(AssociationRule rule) {
        return (float) getSupport(rule.getUnion()) / getSupport(rule.getAntecedent());
    }

    /**
     * Returns the number of transactions contained in this database
     *
     * @return number of transactions in this database
     */
    public int getNumberOfTransactions() {
        return transactions.size();
    }

    /**
     * Returns all frequent 1-itemsets contained in this database for the given minimum support
     *
     * @param minsupp minimum support
     * @return set of freqent 1-itemsets contained in this database
     */
    public Set<Itemset> getFrequent1Itemsets(double minsupp) {
        Set<Itemset> frequent = new HashSet<Itemset>();

        int occurrenceThreshold = (int) (getNumberOfTransactions() * minsupp);

        for (Integer item : allItems) {
            if (itemLookupMap.containsKey(item) && itemLookupMap.get(item).size() > occurrenceThreshold) {
                frequent.add(Itemset.singleton(item));
            }
        }

        return frequent;
    }

    /**
     * Returns the interest value for the given to itemsets
     *
     * @param x itemset x
     * @param y itemset y
     * @return interest value for the itemsets x and y
     */
    public double getInterestValue(Itemset x, Itemset y) {
        Itemset union = x.union(y);

        return Math.abs(getSupport(union) - getSupport(x) * getSupport(y));
    }

    /**
     * Returns the interest value for the given to itemsets where union is the full itemset, x and y are disjoint
     * subsets with x union y = itemset.
     *
     * @param union full itemset
     * @param x     itemset x
     * @param y     itemset y
     * @return interest value for the itemsets x and y
     */
    public double getInterestValue(Itemset union, Itemset x, Itemset y) {
        return Math.abs(getSupport(union) - getSupport(x) * getSupport(y));
    }

    /**
     * Returns the support value for the given itemset. Previously computed support values are cached.
     *
     * @param itemset itemset to return support value for
     * @return support for given itemset
     */
    public double getSupport(Itemset itemset) {
        Double val = supportMap.get(itemset);
        if (val != null) {
            return val;
        }

        assert (transactions != null);

        val = (double) getTransactionsContaining(itemset).size() / transactions.size();

        supportMap.put(itemset, val);

        return val;
    }

    /**
     * Returns the support value supp(Y|X) considering negations
     *
     * @param x
     * @param negatedX
     * @param y
     * @param negatedY
     * @return
     */
    public double getConditionalSupport(Itemset y, boolean negatedY, Itemset x, boolean negatedX) {
        HashSet<Transaction> transactionsForY;

        if (negatedY) {
            transactionsForY = getTransactionsNotContaining(y);
        }
        else {
            transactionsForY = getTransactionsContaining(y);
        }

        HashSet<Transaction> transactionsForX;

        if (negatedX) {
            transactionsForX = getTransactionsNotContaining(x);
        }
        else {
            transactionsForX = getTransactionsContaining(x);
        }

        transactionsForY.retainAll(transactionsForX);

        return (transactionsForY.size()) / ((double) transactionsForX.size());
    }

    /**
     * Returns if the given itemset is an interesting one, i.e., there is an expression i = X union Y with |supp(X union
     * Y) - supp(X)*supp(Y)| >= mininterest
     *
     * @param itemset     itemset to check for interestingness
     * @param mininterest value being lower boundary for interestingness
     * @return true if itemset interesting otherwise false
     */
    public boolean isInteresting(Itemset itemset, double mininterest) {
        Integer[] elemList = itemset.getContent().toArray(new Integer[itemset.size()]);

        boolean[] partition = new boolean[elemList.length - 1];

        int numOfPossibilities = (int) Math.ceil(Math.pow(2, elemList.length - 1));

        for (int i = 0; i < numOfPossibilities; i++) {
            Itemset setA = new Itemset();
            setA.add(elemList[elemList.length - 1]);
            Itemset setB = new Itemset();

            boolean bHasContent = false;
            for (int j = 0; j < partition.length; j++) {
                if (!partition[j]) {
                    setA.add(elemList[j]);
                }
                else {
                    bHasContent = true;
                    setB.add(elemList[j]);
                }
            }

            increment(partition);
            if (!bHasContent) {
                continue;
            }

            double interestVal = getInterestValue(itemset, setA, setB);
            log.debug(itemset.toString(IDResolver.getResolver()) + "[" +
                      setA.toString(IDResolver.getResolver()) + ", " +
                      setB.toString(IDResolver.getResolver()) + "]: " + interestVal + " --> " +
                      (interestVal >= mininterest) + "(Threshold: " + mininterest + ")");
            if (interestVal >= mininterest) {
                return true;
            }
        }
        return false;
    }

    /**
     * Increments the binary number represented by the given int array by 1.
     *
     * @param number array representing the number to increment
     */
    private static void increment(boolean[] number) {
        int idx = 0;
        boolean carry = true;

        while (idx < number.length) {
            boolean val = number[idx];
            number[idx] = val ^ carry;
            carry = val && carry;
            idx++;
        }
    }

    /**
     * Returns the string representation of this transaction database
     *
     * @param resolver
     * @return
     */
    public String toString(IDResolver resolver) {
        StringBuilder sb = new StringBuilder();
        for (Transaction t : transactions) {
            sb.append(t.toString(resolver)).append("\n");
        }

        return sb.toString();
    }

    /**
     * Writes the data contained in this transaction database into the given output stream in a format which is accepted
     * by Weka
     */
    public void writeCSVFormat(OutputStream stream) {
        CSVWriter writer = new CSVWriter(new OutputStreamWriter(stream));

        Integer[] allItemsList = allItems.toArray(new Integer[allItems.size()]);
        String[] firstLine = new String[allItemsList.length];

        for (int i = 0; i < allItemsList.length; i++) {
            firstLine[i] = Integer.toString(allItemsList[i]);
        }

        writer.writeNext(firstLine);

        String[] line = new String[allItemsList.length];
        for (Transaction t : transactions) {
            for (int i = 0; i < allItemsList.length; i++) {
                line[i] = t.contains(allItemsList[i]) ? "yes" : "no";
            }
            writer.writeNext(line);
        }
    }

    /**
     * Writes the data contained in this transaction database into the given output stream using the arff file format
     *
     * @param stream   stream to write generated data to
     * @param resolver
     */
    public void writeARFFFormat(String relationName, OutputStream stream, IDResolver resolver) throws IOException {
        BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(stream));

        writer.write("@relation " + relationName);
        writer.newLine();

        Integer[] allItemsList = allItems.toArray(new Integer[allItems.size()]);

        for (Integer itemId : allItemsList) {
            writer.write("@attribute " + resolver.resolve(itemId) + " {YES,NO}");
            writer.newLine();
        }

        writer.write("@data");
        writer.newLine();

        for (Transaction t : transactions) {
            StringBuilder sb = new StringBuilder();
            boolean first = true;
            for (int i = 0; i < allItemsList.length; i++) {
                if (!first) {
                    sb.append(",");
                }
                else {
                    first = false;
                }
                sb.append(t.contains(allItemsList[i]) ? "YES" : "NO");
            }
            writer.write(sb.toString());
            writer.newLine();
        }
    }
}
